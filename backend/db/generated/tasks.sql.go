// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tasks.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (name, idea) VALUES ($1, $2) RETURNING id, name, idea, completed
`

type CreateTaskParams struct {
	Name string
	Idea string
}

// CREATE
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask, arg.Name, arg.Idea)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Idea,
		&i.Completed,
	)
	return i, err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = $1
`

// DELETE
func (q *Queries) DeleteTask(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTask, id)
	return err
}

const getFilteredTasks = `-- name: GetFilteredTasks :many
SELECT t.ID, t.name, t.idea, t.completed, tg.ID as tag_id, tg.name AS tag_name
FROM tasks t
LEFT JOIN tag_task_relations rel ON rel.task_id = t.ID
LEFT JOIN tags tg ON tg.ID = rel.tag_id
WHERE
	-- where the name is like the task filter (if the filter exists)
	(t.name ILIKE '%' || COALESCE($1::text, t.name) || '%')
	AND
	-- if the tag filter exists, return the rows of the tasks who have a relation to that tag  
	($2::text IS NULL OR 
		EXISTS (
			SELECT 1
			FROM tag_task_relations r2
			-- to get tag id from name
			JOIN tags tg2 
				ON tg2.name = $2::text
			WHERE r2.task_id = t.ID AND r2.tag_id = tg2.id 
		)
	)
ORDER BY t.ID DESC
`

type GetFilteredTasksParams struct {
	TaskName pgtype.Text
	TagName  pgtype.Text
}

type GetFilteredTasksRow struct {
	ID        int32
	Name      string
	Idea      string
	Completed pgtype.Bool
	TagID     pgtype.Int4
	TagName   pgtype.Text
}

func (q *Queries) GetFilteredTasks(ctx context.Context, arg GetFilteredTasksParams) ([]GetFilteredTasksRow, error) {
	rows, err := q.db.Query(ctx, getFilteredTasks, arg.TaskName, arg.TagName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredTasksRow
	for rows.Next() {
		var i GetFilteredTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Idea,
			&i.Completed,
			&i.TagID,
			&i.TagName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextTaskDetails = `-- name: GetNextTaskDetails :one
SELECT name, id FROM tasks WHERE id > $1 ORDER BY id ASC LIMIT 1
`

type GetNextTaskDetailsRow struct {
	Name string
	ID   int32
}

func (q *Queries) GetNextTaskDetails(ctx context.Context, id int32) (GetNextTaskDetailsRow, error) {
	row := q.db.QueryRow(ctx, getNextTaskDetails, id)
	var i GetNextTaskDetailsRow
	err := row.Scan(&i.Name, &i.ID)
	return i, err
}

const getPreviousTaskDetails = `-- name: GetPreviousTaskDetails :one
SELECT name, id FROM tasks WHERE id < $1 ORDER BY id DESC LIMIT 1
`

type GetPreviousTaskDetailsRow struct {
	Name string
	ID   int32
}

func (q *Queries) GetPreviousTaskDetails(ctx context.Context, id int32) (GetPreviousTaskDetailsRow, error) {
	row := q.db.QueryRow(ctx, getPreviousTaskDetails, id)
	var i GetPreviousTaskDetailsRow
	err := row.Scan(&i.Name, &i.ID)
	return i, err
}

const getTaskWithTagRelations = `-- name: GetTaskWithTagRelations :many
SELECT t.ID, t.name, t.idea, t.completed, tg.ID AS tag_id, tg.name AS tag_name
	FROM tasks t
	LEFT JOIN tag_task_relations rel
		ON t.ID = rel.task_id
	LEFT JOIN tags tg 
		ON rel.tag_id = tg.ID
	WHERE t.ID = $1
`

type GetTaskWithTagRelationsRow struct {
	ID        int32
	Name      string
	Idea      string
	Completed pgtype.Bool
	TagID     pgtype.Int4
	TagName   pgtype.Text
}

func (q *Queries) GetTaskWithTagRelations(ctx context.Context, id int32) ([]GetTaskWithTagRelationsRow, error) {
	rows, err := q.db.Query(ctx, getTaskWithTagRelations, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaskWithTagRelationsRow
	for rows.Next() {
		var i GetTaskWithTagRelationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Idea,
			&i.Completed,
			&i.TagID,
			&i.TagName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksWithTagRelations = `-- name: GetTasksWithTagRelations :many
SELECT t.name, t.Idea, t.ID, t.completed, tg.ID AS tag_id, tg.name AS tag_name
		FROM tasks t
		LEFT JOIN tag_task_relations rel 
			ON t.ID = rel.task_id 
		LEFT JOIN tags tg 
			ON tg.ID = rel.tag_id
		ORDER BY t.ID DESC
`

type GetTasksWithTagRelationsRow struct {
	Name      string
	Idea      string
	ID        int32
	Completed pgtype.Bool
	TagID     pgtype.Int4
	TagName   pgtype.Text
}

// READ
func (q *Queries) GetTasksWithTagRelations(ctx context.Context) ([]GetTasksWithTagRelationsRow, error) {
	rows, err := q.db.Query(ctx, getTasksWithTagRelations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTasksWithTagRelationsRow
	for rows.Next() {
		var i GetTasksWithTagRelationsRow
		if err := rows.Scan(
			&i.Name,
			&i.Idea,
			&i.ID,
			&i.Completed,
			&i.TagID,
			&i.TagName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleTaskCompletion = `-- name: ToggleTaskCompletion :exec
UPDATE tasks SET completed = NOT completed WHERE id = $1
`

// UPDATE
func (q *Queries) ToggleTaskCompletion(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, toggleTaskCompletion, id)
	return err
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks
SET
  name = COALESCE($1, name),
  idea = COALESCE($2, idea)
WHERE id = $3
`

type UpdateTaskParams struct {
	Name pgtype.Text
	Idea pgtype.Text
	ID   int32
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.Exec(ctx, updateTask, arg.Name, arg.Idea, arg.ID)
	return err
}
