// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tasks.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (name, idea, user_id) VALUES ($1, $2, $3) RETURNING id, name, idea, completed, created_at, updated_at, user_id
`

type CreateTaskParams struct {
	Name   string
	Idea   string
	UserID int32
}

// CREATE
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask, arg.Name, arg.Idea, arg.UserID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Idea,
		&i.Completed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
	)
	return i, err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = $1 AND user_id = $2
`

type DeleteTaskParams struct {
	ID     int32
	UserID int32
}

// DELETE
func (q *Queries) DeleteTask(ctx context.Context, arg DeleteTaskParams) error {
	_, err := q.db.Exec(ctx, deleteTask, arg.ID, arg.UserID)
	return err
}

const getFilteredTasks = `-- name: GetFilteredTasks :many
SELECT t.name, t.idea, t.ID, t.completed, t.user_id, 
		tg.ID AS tag_id, tg.name AS tag_name, tg.user_id AS tag_user_id
FROM tasks t
LEFT JOIN tag_task_relations rel ON rel.task_id = t.ID
LEFT JOIN tags tg ON tg.ID = rel.tag_id
WHERE
	-- where the name is like the task filter (if the filter exists)
	(t.name ILIKE '%' || COALESCE($2::text, t.name) || '%')
	AND
	-- if the tag filter exists, return the rows of the tasks who have a relation to that tag  
	($3::text IS NULL OR 
		EXISTS (
			SELECT 1
			FROM tag_task_relations r2
			-- to get tag id from name
			JOIN tags tg2 
				ON tg2.name = $3::text
			WHERE r2.task_id = t.ID AND r2.tag_id = tg2.id 
		)
	)
	AND tg.user_id = $1 AND t.user_id = $1
ORDER BY t.ID DESC
`

type GetFilteredTasksParams struct {
	UserID   int32
	TaskName pgtype.Text
	TagName  pgtype.Text
}

type GetFilteredTasksRow struct {
	Name      string
	Idea      string
	ID        int32
	Completed pgtype.Bool
	UserID    int32
	TagID     pgtype.Int4
	TagName   pgtype.Text
	TagUserID pgtype.Int4
}

func (q *Queries) GetFilteredTasks(ctx context.Context, arg GetFilteredTasksParams) ([]GetFilteredTasksRow, error) {
	rows, err := q.db.Query(ctx, getFilteredTasks, arg.UserID, arg.TaskName, arg.TagName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredTasksRow
	for rows.Next() {
		var i GetFilteredTasksRow
		if err := rows.Scan(
			&i.Name,
			&i.Idea,
			&i.ID,
			&i.Completed,
			&i.UserID,
			&i.TagID,
			&i.TagName,
			&i.TagUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextTaskDetails = `-- name: GetNextTaskDetails :one
SELECT name, id FROM tasks WHERE id > $1 AND user_id = $2  ORDER BY id ASC LIMIT 1
`

type GetNextTaskDetailsParams struct {
	ID     int32
	UserID int32
}

type GetNextTaskDetailsRow struct {
	Name string
	ID   int32
}

func (q *Queries) GetNextTaskDetails(ctx context.Context, arg GetNextTaskDetailsParams) (GetNextTaskDetailsRow, error) {
	row := q.db.QueryRow(ctx, getNextTaskDetails, arg.ID, arg.UserID)
	var i GetNextTaskDetailsRow
	err := row.Scan(&i.Name, &i.ID)
	return i, err
}

const getPreviousTaskDetails = `-- name: GetPreviousTaskDetails :one
SELECT name, id FROM tasks WHERE id < $1 AND user_id = $2 ORDER BY id DESC LIMIT 1
`

type GetPreviousTaskDetailsParams struct {
	ID     int32
	UserID int32
}

type GetPreviousTaskDetailsRow struct {
	Name string
	ID   int32
}

func (q *Queries) GetPreviousTaskDetails(ctx context.Context, arg GetPreviousTaskDetailsParams) (GetPreviousTaskDetailsRow, error) {
	row := q.db.QueryRow(ctx, getPreviousTaskDetails, arg.ID, arg.UserID)
	var i GetPreviousTaskDetailsRow
	err := row.Scan(&i.Name, &i.ID)
	return i, err
}

const getTaskWithTagRelations = `-- name: GetTaskWithTagRelations :many
SELECT t.ID, t.name, t.idea, t.completed, t.user_id,
	tg.ID AS tag_id, tg.name AS tag_name, tg.user_id AS tag_user_id
	FROM tasks t
	LEFT JOIN tag_task_relations rel
		ON t.ID = rel.task_id
	LEFT JOIN tags tg 
		ON rel.tag_id = tg.ID
	WHERE t.ID = $1 AND t.user_id = $2 AND tg.user_id = $2
`

type GetTaskWithTagRelationsParams struct {
	ID     int32
	UserID int32
}

type GetTaskWithTagRelationsRow struct {
	ID        int32
	Name      string
	Idea      string
	Completed pgtype.Bool
	UserID    int32
	TagID     pgtype.Int4
	TagName   pgtype.Text
	TagUserID pgtype.Int4
}

func (q *Queries) GetTaskWithTagRelations(ctx context.Context, arg GetTaskWithTagRelationsParams) ([]GetTaskWithTagRelationsRow, error) {
	rows, err := q.db.Query(ctx, getTaskWithTagRelations, arg.ID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaskWithTagRelationsRow
	for rows.Next() {
		var i GetTaskWithTagRelationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Idea,
			&i.Completed,
			&i.UserID,
			&i.TagID,
			&i.TagName,
			&i.TagUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksWithTagRelations = `-- name: GetTasksWithTagRelations :many
SELECT t.name, t.Idea, t.ID, t.completed, t.user_id, 
		tg.ID AS tag_id, tg.name AS tag_name, tg.user_id AS tag_user_id
		FROM tasks t
		LEFT JOIN tag_task_relations rel 
			ON t.ID = rel.task_id 
		LEFT JOIN tags tg 
			ON tg.ID = rel.tag_id
		WHERE t.user_id = $1 AND tg.user_id = $2
		ORDER BY t.ID DESC
`

type GetTasksWithTagRelationsParams struct {
	UserID   int32
	UserID_2 int32
}

type GetTasksWithTagRelationsRow struct {
	Name      string
	Idea      string
	ID        int32
	Completed pgtype.Bool
	UserID    int32
	TagID     pgtype.Int4
	TagName   pgtype.Text
	TagUserID pgtype.Int4
}

// READ
func (q *Queries) GetTasksWithTagRelations(ctx context.Context, arg GetTasksWithTagRelationsParams) ([]GetTasksWithTagRelationsRow, error) {
	rows, err := q.db.Query(ctx, getTasksWithTagRelations, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTasksWithTagRelationsRow
	for rows.Next() {
		var i GetTasksWithTagRelationsRow
		if err := rows.Scan(
			&i.Name,
			&i.Idea,
			&i.ID,
			&i.Completed,
			&i.UserID,
			&i.TagID,
			&i.TagName,
			&i.TagUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleTaskCompletion = `-- name: ToggleTaskCompletion :exec
UPDATE tasks SET completed = NOT completed WHERE id = $1 AND user_id = $2
`

type ToggleTaskCompletionParams struct {
	ID     int32
	UserID int32
}

// UPDATE
func (q *Queries) ToggleTaskCompletion(ctx context.Context, arg ToggleTaskCompletionParams) error {
	_, err := q.db.Exec(ctx, toggleTaskCompletion, arg.ID, arg.UserID)
	return err
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks
SET
  name = COALESCE($1, name),
  idea = COALESCE($2, idea)
WHERE id = $3::int AND user_id = $4::int
`

type UpdateTaskParams struct {
	Name   pgtype.Text
	Idea   pgtype.Text
	ID     int32
	UserID int32
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.Exec(ctx, updateTask,
		arg.Name,
		arg.Idea,
		arg.ID,
		arg.UserID,
	)
	return err
}
