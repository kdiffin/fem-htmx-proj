// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tasks.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :one
WITH authorized_user AS (
  SELECT 1
  FROM vault_user_relations
  WHERE user_id = $3::UUID
    AND vault_id = $4::UUID
    AND (role = 'owner' OR role = 'collaborator')
)
INSERT INTO tasks (name, idea, user_id, vault_id) 
SELECT $1, $2, $3::UUID, $4::UUID
FROM authorized_user RETURNING id
`

type CreateTaskParams struct {
	Name    string
	Idea    string
	UserID  pgtype.UUID
	VaultID pgtype.UUID
}

// CREATE
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.Name,
		arg.Idea,
		arg.UserID,
		arg.VaultID,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks t
WHERE 
	t.id = $1
	AND EXISTS(
		SELECT 1 FROM vault_user_relations v_u_rel
		WHERE v_u_rel.user_id = $2::UUID 
		AND v_u_rel.vault_id = $3::UUID
		AND (role = 'owner' OR role = 'collaborator')
)
`

type DeleteTaskParams struct {
	ID      pgtype.UUID
	UserID  pgtype.UUID
	VaultID pgtype.UUID
}

// DELETE
func (q *Queries) DeleteTask(ctx context.Context, arg DeleteTaskParams) error {
	_, err := q.db.Exec(ctx, deleteTask, arg.ID, arg.UserID, arg.VaultID)
	return err
}

const getFilteredTasks = `-- name: GetFilteredTasks :many
WITH t_with_author AS (
  SELECT t.id, t.name, t.idea, t.completed, t.user_id, t.vault_id, t.created_at, t.updated_at,
         u.path_to_pfp, u.username
  FROM tasks t
  JOIN users u ON t.user_id = u.id
)
SELECT t_with_author.name, t_with_author.idea, t_with_author.ID, t_with_author.vault_id, t_with_author.completed, t_with_author.user_id, t_with_author.created_at, t_with_author.updated_at,
		tg.ID AS tag_id, tg.name AS tag_name, tg.user_id AS tag_user_id,
    	t_with_author.path_to_pfp AS author_path_to_pfp, t_with_author.username AS author_username
FROM t_with_author
LEFT JOIN tag_task_relations rel ON rel.task_id = t_with_author.ID
LEFT JOIN tags tg ON tg.ID = rel.tag_id
WHERE
	-- where the name is like the task filter (if the filter exists)
	(t_with_author.name ILIKE '%' || COALESCE($1::text, t_with_author.name) || '%')
	AND
	 
	-- if the tag filter exists, return the rows of the tasks who have a relation to that tag  
	($2::text IS NULL OR 
		EXISTS (
			SELECT 1
			FROM tag_task_relations r2
			-- to get tag id from name
			JOIN tags tg2 
				ON tg2.name = $2::text
			WHERE r2.task_id = t_with_author.ID AND r2.tag_id = tg2.id
		)
	)
	AND EXISTS(
		SELECT 1 FROM vault_user_relations v_u_rel
		WHERE v_u_rel.user_id = $3::UUID 
		AND v_u_rel.vault_id = $4::UUID
	)
	AND
	t_with_author.vault_id = $4::UUID
ORDER BY t_with_author.created_at DESC
`

type GetFilteredTasksParams struct {
	TaskName pgtype.Text
	TagName  pgtype.Text
	UserID   pgtype.UUID
	VaultID  pgtype.UUID
}

type GetFilteredTasksRow struct {
	Name            string
	Idea            string
	ID              pgtype.UUID
	VaultID         pgtype.UUID
	Completed       bool
	UserID          pgtype.UUID
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	TagID           pgtype.UUID
	TagName         pgtype.Text
	TagUserID       pgtype.UUID
	AuthorPathToPfp string
	AuthorUsername  string
}

func (q *Queries) GetFilteredTasks(ctx context.Context, arg GetFilteredTasksParams) ([]GetFilteredTasksRow, error) {
	rows, err := q.db.Query(ctx, getFilteredTasks,
		arg.TaskName,
		arg.TagName,
		arg.UserID,
		arg.VaultID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredTasksRow
	for rows.Next() {
		var i GetFilteredTasksRow
		if err := rows.Scan(
			&i.Name,
			&i.Idea,
			&i.ID,
			&i.VaultID,
			&i.Completed,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TagID,
			&i.TagName,
			&i.TagUserID,
			&i.AuthorPathToPfp,
			&i.AuthorUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextTaskDetails = `-- name: GetNextTaskDetails :one
WITH authorized_user AS (
  SELECT vault_id, user_id
  FROM vault_user_relations
  WHERE user_id = $2::UUID
    AND vault_id = $3::UUID
    AND (role = 'owner' OR role = 'collaborator')
)
SELECT t.name, t.id FROM tasks t
JOIN authorized_user a_u 
	ON a_u.user_id = $2::UUID 
	AND a_u.vault_id = $3::UUID
WHERE created_at > $1
	AND EXISTS(
		SELECT 1 FROM vault_user_relations v_u_rel
		WHERE v_u_rel.user_id = $2::UUID 
		AND v_u_rel.vault_id = $3::UUID
	)
	AND a_u.vault_id  = t.vault_id
ORDER BY created_at ASC LIMIT 1
`

type GetNextTaskDetailsParams struct {
	CreatedAt pgtype.Timestamp
	UserID    pgtype.UUID
	VaultID   pgtype.UUID
}

type GetNextTaskDetailsRow struct {
	Name string
	ID   pgtype.UUID
}

func (q *Queries) GetNextTaskDetails(ctx context.Context, arg GetNextTaskDetailsParams) (GetNextTaskDetailsRow, error) {
	row := q.db.QueryRow(ctx, getNextTaskDetails, arg.CreatedAt, arg.UserID, arg.VaultID)
	var i GetNextTaskDetailsRow
	err := row.Scan(&i.Name, &i.ID)
	return i, err
}

const getPreviousTaskDetails = `-- name: GetPreviousTaskDetails :one
WITH authorized_user AS (
  SELECT vault_id, user_id
  FROM vault_user_relations
  WHERE user_id = $2::UUID
    AND vault_id = $3::UUID
    AND (role = 'owner' OR role = 'collaborator')
)
SELECT t.name, t.id FROM tasks t
JOIN authorized_user a_u 
	ON a_u.user_id = $2::UUID 
	AND a_u.vault_id = $3::UUID
WHERE created_at < $1
	AND EXISTS(
		SELECT 1 FROM vault_user_relations v_u_rel
		WHERE v_u_rel.user_id = $2::UUID 
		AND v_u_rel.vault_id = $3::UUID
	)
	AND a_u.vault_id  = t.vault_id
ORDER BY created_at DESC LIMIT 1
`

type GetPreviousTaskDetailsParams struct {
	CreatedAt pgtype.Timestamp
	UserID    pgtype.UUID
	VaultID   pgtype.UUID
}

type GetPreviousTaskDetailsRow struct {
	Name string
	ID   pgtype.UUID
}

// TODO: reimplement
func (q *Queries) GetPreviousTaskDetails(ctx context.Context, arg GetPreviousTaskDetailsParams) (GetPreviousTaskDetailsRow, error) {
	row := q.db.QueryRow(ctx, getPreviousTaskDetails, arg.CreatedAt, arg.UserID, arg.VaultID)
	var i GetPreviousTaskDetailsRow
	err := row.Scan(&i.Name, &i.ID)
	return i, err
}

const getTaskWithTagRelations = `-- name: GetTaskWithTagRelations :many
WITH t_with_author AS (
  SELECT t.id, t.name, t.idea, t.completed, t.user_id, t.vault_id, t.created_at, t.updated_at,
         u.path_to_pfp, u.username
  FROM tasks t
  JOIN users u ON t.user_id = u.id
)
SELECT t_with_author.name, t_with_author.idea, t_with_author.ID, t_with_author.vault_id, t_with_author.completed, t_with_author.user_id, t_with_author.created_at, t_with_author.updated_at,
		tg.ID AS tag_id, tg.name AS tag_name, tg.user_id AS tag_user_id,
    	t_with_author.path_to_pfp AS author_path_to_pfp, t_with_author.username AS author_username
FROM t_with_author
LEFT JOIN tag_task_relations rel
	ON t_with_author.ID = rel.task_id
LEFT JOIN tags tg 
	ON rel.tag_id = tg.ID
WHERE t_with_author.ID = $1::UUID 
  	-- authorization, checks if user is inside of this vault
	AND EXISTS(
		SELECT 1 FROM vault_user_relations v_u_rel
		WHERE v_u_rel.user_id = $2::UUID 
		AND v_u_rel.vault_id = $3::UUID
)
ORDER BY t_with_author.created_at DESC
`

type GetTaskWithTagRelationsParams struct {
	ID      pgtype.UUID
	UserID  pgtype.UUID
	VaultID pgtype.UUID
}

type GetTaskWithTagRelationsRow struct {
	Name            string
	Idea            string
	ID              pgtype.UUID
	VaultID         pgtype.UUID
	Completed       bool
	UserID          pgtype.UUID
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	TagID           pgtype.UUID
	TagName         pgtype.Text
	TagUserID       pgtype.UUID
	AuthorPathToPfp string
	AuthorUsername  string
}

func (q *Queries) GetTaskWithTagRelations(ctx context.Context, arg GetTaskWithTagRelationsParams) ([]GetTaskWithTagRelationsRow, error) {
	rows, err := q.db.Query(ctx, getTaskWithTagRelations, arg.ID, arg.UserID, arg.VaultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTaskWithTagRelationsRow
	for rows.Next() {
		var i GetTaskWithTagRelationsRow
		if err := rows.Scan(
			&i.Name,
			&i.Idea,
			&i.ID,
			&i.VaultID,
			&i.Completed,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TagID,
			&i.TagName,
			&i.TagUserID,
			&i.AuthorPathToPfp,
			&i.AuthorUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksWithTagRelations = `-- name: GetTasksWithTagRelations :many
WITH t_with_author AS (
  SELECT t.id, t.name, t.idea, t.completed, t.user_id, t.vault_id, t.created_at, t.updated_at,
         u.path_to_pfp, u.username
  FROM tasks t
  JOIN users u ON t_with_author.user_id = u.id
)
SELECT t_with_author.name, t_with_author.idea, t_with_author.ID, t_with_author.vault_id, t_with_author.completed, t_with_author.user_id, t_with_author.created_at, t_with_author.updated_at,
		tg.ID AS tag_id, tg.name AS tag_name, tg.user_id AS tag_user_id,
    	t_with_author.path_to_pfp AS author_path_to_pfp, t_with_author.username AS author_username
FROM t_with_author
LEFT JOIN tag_task_relations rel 
	ON t_with_author.ID = rel.task_id 
LEFT JOIN tags tg 
	ON tg.ID = rel.tag_id
WHERE
	vault_id = $1::UUID
  	-- authorization, checks if user is inside of this vault
	AND EXISTS(
		SELECT 1 FROM vault_user_relations v_u_rel
		WHERE v_u_rel.user_id = $2::UUID 
		AND v_u_rel.vault_id = $1::UUID
	)
ORDER BY t_with_author.created_at DESC
`

type GetTasksWithTagRelationsParams struct {
	VaultID pgtype.UUID
	UserID  pgtype.UUID
}

type GetTasksWithTagRelationsRow struct {
	Name            string
	Idea            string
	ID              pgtype.UUID
	VaultID         pgtype.UUID
	Completed       bool
	UserID          pgtype.UUID
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	TagID           pgtype.UUID
	TagName         pgtype.Text
	TagUserID       pgtype.UUID
	AuthorPathToPfp string
	AuthorUsername  string
}

// READ
func (q *Queries) GetTasksWithTagRelations(ctx context.Context, arg GetTasksWithTagRelationsParams) ([]GetTasksWithTagRelationsRow, error) {
	rows, err := q.db.Query(ctx, getTasksWithTagRelations, arg.VaultID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTasksWithTagRelationsRow
	for rows.Next() {
		var i GetTasksWithTagRelationsRow
		if err := rows.Scan(
			&i.Name,
			&i.Idea,
			&i.ID,
			&i.VaultID,
			&i.Completed,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TagID,
			&i.TagName,
			&i.TagUserID,
			&i.AuthorPathToPfp,
			&i.AuthorUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleTaskCompletion = `-- name: ToggleTaskCompletion :exec
UPDATE tasks SET completed = NOT completed
WHERE 
	id = $1::UUID
	AND EXISTS(
		SELECT 1 FROM vault_user_relations v_u_rel
		WHERE v_u_rel.user_id = $2::UUID 
		AND v_u_rel.vault_id = $3::UUID
	    AND (role = 'owner' OR role = 'collaborator')
)
`

type ToggleTaskCompletionParams struct {
	ID      pgtype.UUID
	UserID  pgtype.UUID
	VaultID pgtype.UUID
}

// UPDATE
func (q *Queries) ToggleTaskCompletion(ctx context.Context, arg ToggleTaskCompletionParams) error {
	_, err := q.db.Exec(ctx, toggleTaskCompletion, arg.ID, arg.UserID, arg.VaultID)
	return err
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks
SET
  name = COALESCE($1, name),
  idea = COALESCE($2, idea)
WHERE 
	id = $3::UUID
	AND EXISTS(
		SELECT 1 FROM vault_user_relations v_u_rel
		WHERE v_u_rel.user_id = $4::UUID 
		AND v_u_rel.vault_id = $5::UUID
	    AND (role = 'owner' OR role = 'collaborator')
)
`

type UpdateTaskParams struct {
	Name    pgtype.Text
	Idea    pgtype.Text
	ID      pgtype.UUID
	UserID  pgtype.UUID
	VaultID pgtype.UUID
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.Exec(ctx, updateTask,
		arg.Name,
		arg.Idea,
		arg.ID,
		arg.UserID,
		arg.VaultID,
	)
	return err
}
